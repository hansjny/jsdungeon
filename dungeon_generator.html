<html>

<head></head>

<body>
<canvas id="grid" width="1800" height="1800"></canvas>
</body>
</html>


<script>
    var c = document.getElementById("grid");
    var ctx = c.getContext("2d");
    var grid_w = 100
    var grid_h = 100
    var grid_s = 13
    const imageURL = [{path: "images/black_tile.png", name : "black_tile"},
    {path :"images/white_tile.png", name : "white_tile"},
    {path :"images/water.png", name : "water"}]; 

    const images = {}
    var imageCount = 0; 


    var enumerate = false
    let NORTH = 1
    let EAST =  2
    let SOUTH = 3
    let WEST = 4
    var NESW = [NORTH, EAST, SOUTH, WEST]

    function fill_pos(x, y, color) {
        ctx.fillStyle = color
        ctx.fillRect(0 + grid_s * x, 0 + grid_s * y, grid_s, grid_s);
    }
    function fill_image(x, y, img) {
        ctx.drawImage(images[img], 0 + grid_s * x, 0 + grid_s * y, grid_s, grid_s); 
    }

    function fill_line(x1, y1, x2, y2, offsetX, offsetY) {
            ctx.beginPath();       // Start a new path
            ctx.lineWidth = 2;
            ctx.strokeStyle = "black";
            //console.log(grid_s * x1 + offsetX * grid_s, grid_s * y1 + offsetY * grid_s)
            ctx.moveTo(grid_s * x1 + offsetX * grid_s + grid_s/2, grid_s * y1 + offsetY * grid_s + grid_s/2);    // Move the pen to (30, 50)
            ctx.lineTo(grid_s * x2 + offsetX * grid_s + grid_s/2, grid_s * y2 + offsetY * grid_s + grid_s/2);    // Move the pen to (30, 50)
            ctx.stroke();    
            ctx.beginPath();
            ctx.strokeStyle = "blue";
            ctx.arc(grid_s * x1 + offsetX * grid_s + grid_s/2, grid_s * y1 + offsetY * grid_s + grid_s/2, 2, 0, 2 * Math.PI);
            ctx.stroke();
    }

    function random(from, to) {
        return Math.floor(Math.random() * (to - from) + from)
    }
    const celltype = {
        EMPTY: 0,
	    BORDER: 1,
	    ROOM_FLOOR: 2,
	    ROOM_DOOR: 3,
        ROCK: 4
    }


    class Pos 
    {
        constructor(x, y) {
            this.x = x
            this.y = y
        }

        distanceTo(pos) {
            return Math.sqrt(Math.pow((pos.x - this.x), 2) + Math.pow(pos.y - this.y, 2))
        }

        equals(pos) {
            return pos.x == this.x && pos.y == this.y
        }

    }


    class Door 
    {
        constructor(pos, house, dir) {
            this.pos = pos
            this.conntected = false
            this.owner = house
            this.direction = dir
        }
    }


    class House 
    {
        constructor(sizeW, sizeH, owner, id) {
            this.doors = []
            this.owner = owner
            this.size_w = sizeW
            this.size_h = sizeH
            this.door_e = false
            this.door_w = false
            this.door_n = false
            this.door_s = false
            this.connectedTo = null
            this.id = id
            this.x = 0
            this.y = 0
        }

        connect(house) {
            this.connectedTo = house
        }

        getDoors() {
            return this.doors
        }
        addDoor(door)  {
            this.doors.push(door)
        }

        getCenterPos() {
            return new Pos(this.x + (this.size_w - 1) / 2, this.y + (this.size_h - 1) / 2 )
        }
        
        getPos() {
            return new Pos(this.x, this.y)
        }
        printIdentity() {
            return "House: " + this.x + " " + this.y
        }

        makeDoors() {
            var door_distribution = [1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4]
            var door_count = door_distribution[random(0, door_distribution.length -1)]
            var current_door_count = 0;
            var doors = ["door_w", "door_e", "door_n", "door_s" ]
            while (current_door_count < door_count) {
                var door_dir = doors[random(0, doors.length)]
                if (this[door_dir] == false) {
                    this[door_dir] = true;
                    current_door_count++;
                }
            }
        }
        placeDoors() {
            var y = this.y
            var x = this.x
            for (var i = y; i < y + this.size_h; i++)
                for (var j = x; j < x + this.size_w; j++)
                    if (j == x && this.door_w && i == y + (this.size_h - 1) / 2 ) {
                        this.owner.placeDoor(i, j, 0, -1)
                    }
                    else if (j == x + (this.size_w - 1) && this.door_e && i == y + (this.size_h - 1) / 2 ) {
                        this.owner.placeDoor(i, j, 0, 1)
                    }
                    else if (j == x + (this.size_w - 1) / 2 && this.door_n && i == y ) {
                        this.owner.placeDoor(i, j, -1, 0)
                    }
                    else if (j == x + (this.size_w - 1) / 2 && this.door_s && i == y + (this.size_h - 1) ) {
                        this.owner.placeDoor(i, j, 1, 0)
                    }
        }
    }

    class Zone 
    {
        constructor(startPosX, startPosY, sizeX, sizeY) {
            this.startX     =   startPosX
            this.startY     =   startPosY
            this.endX       =   startPosX + sizeX
            this.endY     =   startPosY + sizeY
            this.size_w = sizeX
            this.size_h = sizeY
            this.colors = ["red", "blue", "green", "purple", "teal", "black", "pink", "yellow", "orange"]
            this.grid = new Array(this.size_h);
            this.houseSize = [3, 5, 7]
            this.houses = []
            this.connectedHouses = []
            this.rockChance = 0.87
            console.error(" GRID SIZE height: ", this.size_h, "width: ", this.size_h)
            for (var i = 0; i < this.size_h; i++) {
                this.grid[i] = new Array(this.size_w);
                for (var j = 0; j < this.size_w; j++) 
                {
                    if (Math.random() < this.rockChance)
                        this.grid[i][j] = celltype.EMPTY
                    else
                        this.grid[i][j] = celltype.ROCK
                }
            }
        }

        drawBorder() {
            for (var y = 0; y < this.size_h; y++)
             {
                for (var x = 0; x < this.size_w; x++) 
                {
                    if (x == 0 || x == this.size_w -1 || y == 0 || y == this.size_h - 1) 
                        fill_pos(x + this.startX, y + this.startY, "red")
                }
            }
        }

        drawPos(pos, color) 
        {
            fill_pos(pos.x + this.startX, pos.y + this.startY, color)
        }

        drawImagePos(pos, image) {
            fill_image(pos.x + this.startX, pos.y + this.startY, image)
        }

        distanceBetweenHouses(house1, house2) {
            var pos1 = house1.getCenterPos()
            var pos2 = house2.getCenterPos()
            var dist = pos1.distanceTo(pos2)
            return dist
        }

        selectDirection() {
            var rand = Math.floor(Math.random() * 4)
            return NESW[rand];
        }

        makeHouses(num) 
        {
            var houses = Array()
            for (var i = 0; i < num; i++) {
                var size = this.houseSize[random(0, this.houseSize.length)]
                var house = new House(size, size, this, i)
                houses.push(house)
                house.makeDoors()
            }
            return houses
        }

        empty(y, x) {
            if (y >= this.size_w || this.x >= this.size_w || y <= 0 || x <= 0)
                return false
            return (this.grid[y][x] == celltype.EMPTY)
        }
        

        emptyTile(tile) {
            return tile == celltype.EMPTY || tile == celltype.ROCK
        } 

        placeDoor(y, x, ymod, xmod) {
            if (y > 0 && this.emptyTile(this.grid[y + ymod][x + xmod]))
                this.grid[y][x] = celltype.ROOM_DOOR
            else
                this.grid[y][x] = celltype.ROOM_FLOOR
        }

        addHouse(y, x, house) {
            this.houses.push(house)
            house.x = x;
            house.y = y;
            for (var i = y; i < y + house.size_h; i++)
                for (var j = x; j < x + house.size_w; j++)
                    this.grid[i][j] = celltype.ROOM_FLOOR

        }

        canPlaceHouse(x, y, house) {
            var w = house.size_w
            var h = house.size_h
            var spacing = 3
            var edge_spacing = 5

            if (x < edge_spacing || x + w > this.size_w - edge_spacing || y < edge_spacing || y + h > this.size_h - edge_spacing)
                return false

            var startX = (x - spacing < 0) ? 0 : x - spacing
            var endX = (x + spacing + w > this.size_w) ? this.size_w : x + spacing + w
            var startY = (y - spacing < 0) ? 0 : y - spacing
            var endY = (y + spacing + h > this.size_h) ? this.size_h : y + spacing + h


            var canPlace = true
            for (var i = startY; i < endY; i++) {
                for (var j = startX; j < endX; j++) {
                    if (this.grid[i][j] == celltype.ROOM_FLOOR) {
                        canPlace = false
                        break
                    }

                    if (j > x && j < x + w && i > y && i < y + h) {
                        if (this.grid[i][j] == celltype.ROCK) {
                            canPlace = false
                            break
                        }
                    }
                }
            }


            return canPlace
        }

        placeHouse(house) {
            var w = house.size_w
            var h = house.size_h
            for (var y = 0; y < this.size_h; y += h) 
            {
                for (var x = 0; x < this.size_w; x += w ) 
                {
                    var random_wiggle_x = random(x - (random(1, 20)), x + random(1, 20))
                    var random_wiggle_y = random(y - (random(1, 20)), y + random(1, 20))
                    if (this.canPlaceHouse(random_wiggle_x, random_wiggle_y, house)) 
                    {
                        this.addHouse(random_wiggle_y,random_wiggle_x, house)

                        // house.placeDoors()
                        return
                    }
                }
            }

        }

        houseConnected(house) {
            for (var i = 0; i < this.connectedHouses.length; i++){
                if (this.connectedHouses[i].id == house.id) {
                    return true
                }
            }
            return false
        }

        connectHouses(house) {
            var houses = this.houses
            var currentHouse = house
            var minimumDistance = Infinity;
            var currentNeighbour = null;
            this.connectedHouses.push(currentHouse)
            if (house.connectedTo != null) {
                return null
            }

            for (var j = 0; j < houses.length; j++) {
                if (houses[j] != currentHouse) {
                    var computed_dist = this.distanceBetweenHouses(currentHouse, houses[j])
                    // console.log(computed_dist, minimumDistance, computed_dist < minimumDistance, this.houseConnected(house[j]))
                    if ( computed_dist < minimumDistance && !this.houseConnected(houses[j])) {
                        minimumDistance = computed_dist;
                        currentNeighbour = houses[j]
                    }
                }
            }
            if (currentNeighbour == null) {
                return null
            }
            currentHouse.connect(currentNeighbour) 
            currentHouse = currentNeighbour
            currentNeighbour = null
            this.connectHouses(currentHouse)
        }

        drawConnection(house1, house2) {
            if (house1 == null || house2 == null)
                return
            fill_line(house1.getCenterPos().x, house1.getCenterPos().y, house2.getCenterPos().x, house2.getCenterPos().y, this.startX, this.startY)
        }


        isValidPos(pos) {
            if (pos.y >= this.size_h || pos.y <= 0 || pos.x >= this.size_w || pos.x <= 0)
                return false
            return true
        }

        isRock(pos) {
            if (this.grid[pos.y][pos.x] == celltype.ROCK)
                return true
            return false
        }

        drawTrace(node) {
            var cur = node
            this.grid[cur.pos.y][cur.pos.x] = celltype.ROOM_FLOOR
            while (cur.parent != null) {
                this.grid[cur.parent.pos.y][cur.parent.pos.x] = celltype.ROOM_FLOOR
                cur = cur.parent
            }
        }
        AStarConnectNodes(pos1, pos2) {
            class AStarNode {
                constructor(pos, f, g, parent) {
                    this.pos = pos
                    this.f = f
                    this.g = g
                    this.parent = parent
                }
            }
            var endpos = pos2
            var open = [new AStarNode(pos1, 0, 0, null)]
            var closed = []

            while (open.length > 0) {
                var least_f = Infinity
                var q = null
                for (var i = 0; i < open.length; i++) {
                    if (open[i].f < least_f) {
                        least_f = open[i].f
                        q = open[i]
                    }
                }
                var loc = open.indexOf(q)
                if (loc > -1) {
                    open.splice(loc, 1)
                }

                var positions = [new Pos(q.pos.x - 1, q.pos.y),
                new Pos(q.pos.x + 1, q.pos.y),
                new Pos(q.pos.x, q.pos.y + 1),
                new Pos(q.pos.x, q.pos.y - 1)]

                for (var j = 0; j < positions.length; j++) {
                    var newPos = positions[j]
                    if (!this.isValidPos(newPos)) {
                        continue
                    }
                    if (newPos.equals(endpos)) {
                        this.drawTrace(new AStarNode(newPos, 0, 0, q))
                        console.log("FOUND DESTINATION")
                        return;
                    }

                    var penalty = 0
                    if (this.isRock(newPos)) {
                        penalty = 10
                    }
                    var h = endpos.distanceTo(newPos) + penalty
                    var g = q.g + 1
                    var f = h + g

                    var skip = false

                    for (var i = 0; i < open.length; i++) {
                        if (open[i].pos.equals(newPos)) {
                            if (f > open[i].f) {
                                skip = true
                            }
                        }
                    }

                    for (var i = 0; i < closed.length; i++) {
                        if (closed[i].pos.equals(newPos)) {
                            if (closed[i].f < f) {
                                skip = true
                            }
                        }
                    }

                    if (skip)
                        continue

                    open.push(new AStarNode(newPos, g, f, q))
                }
                closed.push(q)
            }
        }

        drawHouseDoor(house, dir) {
            var pos = house.getCenterPos()
            var door_entry_len = 2
            switch(dir) {
                case NESW[NORTH]:
                    // this.grid[pos.y - (house.size_h - 1) / 2][pos.x] = celltype.ROOM_DOOR
                    for (i = 1; i <= door_entry_len; i++) 
                        this.grid[-i + pos.y - (house.size_h - 1) / 2][pos.x] = celltype.ROOM_FLOOR
                    return new Pos(pos.x, pos.y - 2 - (house.size_h - 1) / 2)
                case NESW[SOUTH]:
                    // this.grid[pos.y + (house.size_h - 1) / 2][pos.x] = celltype.ROOM_DOOR
                    for (i = 1; i <= door_entry_len; i++) 
                        this.grid[i + pos.y + (house.size_h - 1) / 2][pos.x] = celltype.ROOM_FLOOR
                    return new Pos(pos.x, pos.y + 2 + (house.size_h - 1) / 2) 
                case NESW[EAST]:
                    // this.grid[pos.y][pos.x + (house.size_w - 1) / 2] = celltype.ROOM_DOOR
                    for (i = 1; i <= door_entry_len; i++) 
                        this.grid[pos.y][i + pos.x + (house.size_w - 1) / 2] = celltype.ROOM_FLOOR
                    return new Pos(pos.x + 2 + (house.size_w - 1) / 2, pos.y)
                case NESW[WEST]:
                    // this.grid[pos.y][pos.x - (house.size_w - 1) / 2] = celltype.ROOM_DOOR
                    for (i = 1; i <= door_entry_len; i++) 
                        this.grid[pos.y][-i + pos.x - (house.size_w - 1) / 2] = celltype.ROOM_FLOOR
                    return new Pos(pos.x + -2 - (house.size_w - 1) / 2, pos.y)
            }



        }

        findHouseExits(house1, house2) {
            var diff_x = house2.getCenterPos().x - house1.getCenterPos().x
            var diff_y = house2.getCenterPos().y - house1.getCenterPos().y
            var vec_len = Math.sqrt(Math.pow(diff_x, 2) + Math.pow(diff_y, 2))
            var x_norm = diff_x / vec_len
            var y_norm = diff_y / vec_len
            var pos1, pos2
            if (Math.abs(x_norm) > Math.abs(y_norm)) {
                if (x_norm > 0){
                    pos1 = this.drawHouseDoor(house1, NESW[EAST])
                    pos2 = this.drawHouseDoor(house2, NESW[WEST])
                }
                else {
                    pos1 = this.drawHouseDoor(house1, NESW[WEST])
                    pos2 = this.drawHouseDoor(house2, NESW[EAST])
                }
            }
            else {
                if (y_norm > 0) {
                    pos1 =this.drawHouseDoor(house1, NESW[SOUTH])
                    pos2 = this.drawHouseDoor(house2, NESW[NORTH])
                }
                else {
                    pos1 = this.drawHouseDoor(house1, NESW[NORTH])
                    pos2 = this.drawHouseDoor(house2, NESW[SOUTH])
                }

            }
            return [pos1, pos2]

        }
        startGen() {
            var t0 = performance.now()
            var houses = this.makeHouses(30)
            // this.placeHouse(houses[0])
            for (var i = 0; i < houses.length; i++)
                this.placeHouse(houses[i])

            // for (var i = 0; i < houses.length; i++)
            //     this.placeDoors(houses[i])

            this.connectHouses(this.houses[0])

            for (var i = 0; i < this.houses.length; i++) {
                if (this.houses[i].connectedTo == null) {
                    var house = this.houses[i]
                    var closest = Infinity
                    var closest_neighbour = null
                    for ( j = 0; j < this.connectedHouses.length; j++) {
                        var dist = this.distanceBetweenHouses(house, this.connectedHouses[j])
                        if (dist < closest) {
                            closest = dist
                            closest_neighbour = this.connectedHouses[j]
                        }
                    }
                    this.houses[i].connectedTo = closest_neighbour;
                    this.connectedHouses.push(this.houses[i])
                    // while (true) {
                    //     var randval = random(0, this.houses.length) 
                    //     if (randval != i) {
                    //         break;
                    //     }
                    // }
                }
            }
           
            for (var i = 0; i < this.houses.length; i++) {
                if ( this.houses[i].connectedTo != null) {
                    var doors = this.findHouseExits(this.houses[i], this.houses[i].connectedTo)
                    // this.drawPos(doors[0], "red")
                    // this.drawPos(doors[1], "green")
                    this.AStarConnectNodes(doors[0], doors[1])
                }
            }
            var t1 = performance.now()
            console.log("Call to doSomething took " + (t1 - t0) + " milliseconds.")
            this.renderGrid()


            // for (var i = 0; i < this.houses.length; i++) {
            //     this.drawPos(this.houses[i].getCenterPos(), "white")
            // }
            //  for (var i = 0; i < this.connectedHouses.length; i++)
            //      this.drawConnection(this.connectedHouses[i], this.connectedHouses[i].connectedTo)
        }

        renderGrid() {
            for (var y = 0; y < this.size_h; y ++) 
                {
                    for (var x = 0; x < this.size_w; x++ ) 
                    {
                        switch(this.grid[y][x]) {
                            case celltype.EMPTY:
                                fill_image(this.startX + x, this.startY + y, "water")
                                break;
                            case celltype.ROOM_FLOOR:
                                fill_image(this.startX + x, this.startY + y, "black_tile")
                                break;
                            case celltype.ROOM_DOOR:
                                fill_pos(this.startX + x, this.startY + y, "yellow")
                                break;
                            case celltype.ROCK:
                                fill_image(this.startX + x, this.startY + y, "water")
                                // fill_pos(this.startX + x, this.startY + y, "black")
                                break;
                        }
                    }

                }
            }
    }

    var zones = Array()
    zones.push(new Zone(1, 1, 120, 120))
    // zones.push(new Zone(50, 1, 40, 40))
    // zones.push(new Zone(1, 50, 40, 40))
    // zones.push(new Zone(50, 50, 40, 40))



    // draw initial grid
    for (i = 0; i < grid_h; i++)
    {
        for (j = 0; j < grid_w; j++)
        {
            ctx.strokeStyle = "#000"
            ctx.lineWidth = 0.1
            ctx.strokeRect(0 + grid_s * j, 0 + grid_s * i, grid_s, grid_s);
            if (enumerate) {
                ctx.fillStyle = "#000"
                ctx.font = "6px Arial";
                ctx.fillText(i * grid_w + j + "", 0 + grid_s * j + 5, 0 + grid_s * i + 13);
            }
        }
    }

    imageURL.forEach(src => {  
        const image = new Image();
        image.src = src.path;
        image.onload = () => {
            imageCount += 1;
            zones.forEach(zone => {
                zone.drawBorder()
                zone.startGen()
            });
        }
        images[src.name] = image
    });
    // zones[0].drawBorder()
    // zones[0].startGen()
    // grid

</script>