<html>

<head></head>

<body>
<canvas id="grid" width="1300" height="1300"></canvas>
</body>
</html>


<script>
    var c = document.getElementById("grid");
    var ctx = c.getContext("2d");
    var grid_w = 100
    var grid_h = 100
    var grid_s = 12
    var enumerate = false
    let NORTH = {"x" : 0, "y" : -1}
    let EAST =  {"x" : 1, "y" : 0}
    let SOUTH = {"x" : 0, "y" : 1}
    let WEST = {"x" : -1, "y" : 0}
    let NESW = [NORTH, EAST, SOUTH, WEST]
    function fill_pos(x, y, color) {
        ctx.fillStyle = color
        ctx.fillRect(0 + grid_s * x, 0 + grid_s * y, grid_s, grid_s);
    }

    function fill_line(x1, y1, x2, y2, offsetX, offsetY) {
            ctx.beginPath();       // Start a new path
            ctx.lineWidth = 2;
            ctx.strokeStyle = "black";
            console.log("Offset",  offsetX, offsetY)
            console.log(grid_s * x1 + offsetX * grid_s, grid_s * y1 + offsetY * grid_s)
            ctx.moveTo(grid_s * x1 + offsetX * grid_s + grid_s/2, grid_s * y1 + offsetY * grid_s + grid_s/2);    // Move the pen to (30, 50)
            ctx.lineTo(grid_s * x2 + offsetX * grid_s + grid_s/2, grid_s * y2 + offsetY * grid_s + grid_s/2);    // Move the pen to (30, 50)
            ctx.stroke();    
            ctx.beginPath();
            ctx.strokeStyle = "blue";
            ctx.arc(grid_s * x1 + offsetX * grid_s + grid_s/2, grid_s * y1 + offsetY * grid_s + grid_s/2, 2, 0, 2 * Math.PI);
            ctx.stroke();
    }

    function random(from, to) {
        return Math.floor(Math.random() * (to - from) + from)
    }
    const celltype = {
        EMPTY: 0,
	    BORDER: 1,
	    ROOM_FLOOR: 2,
	    ROOM_DOOR: 3,
        ROOM_ROCK: 4
    }


    class Pos 
    {
        constructor(x, y) {
            this.x = x
            this.y = y
        }

        distanceTo(pos) {
            return Math.sqrt(Math.pow((pos.x - this.x), 2) + Math.pow(pos.y - this.y, 2))
        }

    }


    class Door 
    {
        constructor(pos, house, dir) {
            this.pos = pos
            this.conntected = false
            this.owner = house
            this.direction = dir
        }
    }


    class House 
    {
        constructor(sizeW, sizeH, owner, id) {
            this.doors = []
            this.owner = owner
            this.size_w = sizeW
            this.size_h = sizeH
            this.door_e = false
            this.door_w = false
            this.door_n = false
            this.door_s = false
            this.connectedTo = null
            this.id = id
            this.x = 0
            this.y = 0
        }

        connect(house) {
            this.connectedTo = house
        }

        getDoors() {
            return this.doors
        }
        addDoor(door)  {
            this.doors.push(door)
        }

        getCenterPos() {
            return new Pos(this.x + (this.size_w - 1) / 2, this.y + (this.size_h - 1) / 2 )
        }
        
        getPos() {
            return new Pos(this.x, this.y)
        }
        printIdentity() {
            return "House: " + this.x + " " + this.y
        }

        makeDoors() {
            var door_distribution = [1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4]
            var door_count = door_distribution[random(0, door_distribution.length -1)]
            var current_door_count = 0;
            var doors = ["door_w", "door_e", "door_n", "door_s" ]
            while (current_door_count < door_count) {
                var door_dir = doors[random(0, doors.length)]
                if (this[door_dir] == false) {
                    this[door_dir] = true;
                    current_door_count++;
                }
            }
        }
        placeDoors() {
            var y = this.y
            var x = this.x
            for (var i = y; i < y + this.size_h; i++)
                for (var j = x; j < x + this.size_w; j++)
                    if (j == x && this.door_w && i == y + (this.size_h - 1) / 2 ) {
                        this.owner.placeDoor(i, j, 0, -1)
                    }
                    else if (j == x + (this.size_w - 1) && this.door_e && i == y + (this.size_h - 1) / 2 ) {
                        this.owner.placeDoor(i, j, 0, 1)
                    }
                    else if (j == x + (this.size_w - 1) / 2 && this.door_n && i == y ) {
                        this.owner.placeDoor(i, j, -1, 0)
                    }
                    else if (j == x + (this.size_w - 1) / 2 && this.door_s && i == y + (this.size_h - 1) ) {
                        this.owner.placeDoor(i, j, 1, 0)
                    }
        }
    }

    class Zone 
    {
        constructor(startPosX, startPosY, sizeX, sizeY) {
            this.startX     =   startPosX
            this.startY     =   startPosY
            this.endX       =   startPosX + sizeX
            this.endY     =   startPosY + sizeY
            this.size_w = sizeX
            this.size_h = sizeY
            this.colors = ["red", "blue", "green", "purple", "teal", "black", "pink", "yellow", "orange"]
            this.grid = new Array(this.size_h);
            this.houseSize = [3, 5]
            this.houses = []
            this.connectedHouses = []

            console.error(" GRID SIZE height: ", this.size_h, "width: ", this.size_h)
            for (var i = 0; i < this.size_h; i++) {
                this.grid[i] = new Array(this.size_w);
                for (var j = 0; j < this.size_w; j++) 
                {
                    if (Math.random() < 0.75)
                        this.grid[i][j] = celltype.EMPTY
                    else
                        this.grid[i][j] = celltype.ROCK
                }
            }
        }

        drawBorder() {
            for (var y = 0; y < this.size_h; y++)
             {
                for (var x = 0; x < this.size_w; x++) 
                {
                    if (x == 0 || x == this.size_w -1 || y == 0 || y == this.size_h - 1) 
                        fill_pos(x + this.startX, y + this.startY, "red")
                }
            }
        }

        drawPos(pos, color) 
        {
            fill_pos(pos.x + this.startX, pos.y + this.startY, color)
        }

        distanceBetweenHouses(house1, house2) {
            var pos1 = house1.getCenterPos()
            var pos2 = house2.getCenterPos()
            var dist = pos1.distanceTo(pos2)
            return dist
        }

        selectDirection() {
            var rand = Math.floor(Math.random() * 4)
            return NESW[rand];
        }

        makeHouses(num) 
        {
            var houses = Array()
            for (var i = 0; i < num; i++) {
                var size = this.houseSize[random(0, this.houseSize.length)]
                var house = new House(size, size, this, i)
                houses.push(house)
                house.makeDoors()
            }
            return houses
        }

        empty(y, x) {
            if (y >= this.size_w || this.x >= this.size_w || y <= 0 || x <= 0)
                return false
            return (this.grid[y][x] == celltype.EMPTY)
        }
        

        emptyTile(tile) {
            return tile == celltype.EMPTY || tile == celltype.ROCK
        } 

        placeDoor(y, x, ymod, xmod) {
            if (y > 0 && this.emptyTile(this.grid[y + ymod][x + xmod]))
                this.grid[y][x] = celltype.ROOM_DOOR
            else
                this.grid[y][x] = celltype.ROOM_FLOOR
        }

        addHouse(y, x, house) {
            this.houses.push(house)
            house.x = x;
            house.y = y;
            for (var i = y; i < y + house.size_h; i++)
                for (var j = x; j < x + house.size_w; j++)
                    this.grid[i][j] = celltype.ROOM_FLOOR

        }

        canPlaceHouse(x, y, house) {
            var w = house.size_w
            var h = house.size_h
            var spacing = 1

            // Place houses within bounds of given map
            if (y - spacing < 0 || x - spacing < 0 || y + spacing > this.size_h || x + spacing > this.size_w)
                return false


            if (!this.empty(y, x -  spacing ))
                return

            if (!this.empty(y - spacing, x ))
                return

            if (!this.empty(y + h + spacing, x ))
                return

            if (!this.empty(y, x + spacing + w ))
                return

            if (this.empty(y, x) && this.empty(y + h + spacing , x + w + spacing) && this.empty(y + h + spacing, x) && this.empty(y, x + w + spacing)) {
                for (i = y; i < h; i++)
                    for (j = x; j < w; j++)
                        if (!this.empty(i, j))
                            return false
                return true
            }
            return false
        }

        placeHouse(house) {
            var spacing = 1
            var w = house.size_w
            var h = house.size_h
            for (var y = 0; y < this.size_h; y += h) 
            {
                for (var x = 0; x < this.size_w; x += w ) 
                {
                    if (this.canPlaceHouse(x, y, house)) 
                    {
                        this.addHouse(y, x, house)
                        // house.placeDoors()
                        return
                    }
                }
            }

        }

        houseConnected(house) {
            console.log(house)
            for (var i = 0; i < this.connectedHouses.length; i++){
                if (this.connectedHouses[i].id == house.id) {
                    return true
                }
            }
            return false
        }

        connectHouses(house) {
            var houses = this.houses
            var currentHouse = house
            var minimumDistance = Infinity;
            var currentNeighbour = null;
            this.connectedHouses.push(currentHouse)
            if (house.connectedTo != null) {
                console.log("BITCH WE DONE HERE")
                return null
            }

            for (var j = 0; j < houses.length; j++) {
                if (houses[j] != currentHouse) {
                    var computed_dist = this.distanceBetweenHouses(currentHouse, houses[j])
                    // console.log(computed_dist, minimumDistance, computed_dist < minimumDistance, this.houseConnected(house[j]))
                    if ( computed_dist < minimumDistance && !this.houseConnected(houses[j])) {
                        console.log(" in here tho")
                        minimumDistance = computed_dist;
                        currentNeighbour = houses[j]
                    }
                }
            }
            if (currentNeighbour == null) {
                console.log("im null")
                return null
            }
            currentHouse.connect(currentNeighbour) 
            currentHouse = currentNeighbour
            currentNeighbour = null
            console.log(house.printIdentity())
            this.connectHouses(currentHouse)
        }

        drawConnection(house1, house2) {
            if (house1 == null || house2 == null)
                return
            fill_line(house1.getCenterPos().x, house1.getCenterPos().y, house2.getCenterPos().x, house2.getCenterPos().y, this.startX, this.startY)
        }

        startGen() {
            var houses = this.makeHouses(20)
            // this.placeHouse(houses[0])
            for (var i = 0; i < houses.length; i++)
                this.placeHouse(houses[i])

            // for (var i = 0; i < houses.length; i++)
            //     this.placeDoors(houses[i])

            this.connectHouses(this.houses[0])

            console.log(this.connectedHouses)
            this.renderGrid()
            for (var i = 0; i < this.connectedHouses.length; i++)
                this.drawConnection(this.connectedHouses[i], this.connectedHouses[i].connectedTo)
        }

        renderGrid() {
            for (var y = 0; y < this.size_h; y ++) 
                {
                    for (var x = 0; x < this.size_w; x++ ) 
                    {
                        switch(this.grid[y][x]) {
                            case celltype.EMPTY:
                                break;
                            case celltype.ROOM_FLOOR:
                                fill_pos(this.startX + x, this.startY + y, "green")
                                break;
                            case celltype.ROOM_DOOR:
                                fill_pos(this.startX + x, this.startY + y, "yellow")
                                break;
                            case celltype.ROCK:
                                fill_pos(this.startX + x, this.startY + y, "gray")
                                break;
                        }
                    }

                }
            }
    }

    var zones = Array()
    zones.push(new Zone(1, 1, 40, 40))
    zones.push(new Zone(50, 1, 40, 40))
    zones.push(new Zone(1, 50, 40, 40))
    zones.push(new Zone(50, 50, 40, 40))



    // draw initial grid
    for (i = 0; i < grid_h; i++)
    {
        for (j = 0; j < grid_w; j++)
        {
            ctx.strokeStyle = "#000"
            ctx.lineWidth = 0.1
            ctx.strokeRect(0 + grid_s * j, 0 + grid_s * i, grid_s, grid_s);
            if (enumerate) {
                ctx.fillStyle = "#000"
                ctx.font = "6px Arial";
                ctx.fillText(i * grid_w + j + "", 0 + grid_s * j + 5, 0 + grid_s * i + 13);
            }
        }
    }
    // zones[0].drawBorder()
    // zones[0].startGen()
    // grid
    zones.forEach(zone => {
        zone.drawBorder()
        zone.startGen()
    });

</script>