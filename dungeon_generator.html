<html>

<head></head>

<body>
<canvas id="grid" width="1300" height="1300"></canvas>
</body>
</html>


<script>
    var c = document.getElementById("grid");
    var ctx = c.getContext("2d");
    var grid_w = 100
    var grid_h = 100
    var grid_s = 12
    var enumerate = false
    let NORTH = {"x" : 0, "y" : -1}
    let EAST =  {"x" : 1, "y" : 0}
    let SOUTH = {"x" : 0, "y" : 1}
    let WEST = {"x" : -1, "y" : 0}
    let NESW = [NORTH, EAST, SOUTH, WEST]
    function fill_pos(x, y, color) {
        ctx.fillStyle = color
        ctx.fillRect(0 + grid_s * x, 0 + grid_s * y, grid_s, grid_s);
    }

    function random(from, to) {
        console.log(from, to)
        return Math.floor(Math.random() * (to - from) + from)
    }
    const celltype = {
        EMPTY: 0,
	    BORDER: 1,
	    ROOM_FLOOR: 2,
	    ROOM_DOOR: 3,
        ROOM_ROCK: 4
    }
    class Zone 
    {
        constructor(startPosX, startPosY, sizeX, sizeY) 
        {
            this.startX     =   startPosX
            this.startY     =   startPosY
            this.endX       =   startPosX + sizeX
            this.endY     =   startPosY + sizeY
            this.size_w = sizeX
            this.size_h = sizeY
            this.colors = ["red", "blue", "green", "purple", "teal", "black", "pink", "yellow", "orange"]
            this.grid = new Array(this.size_h);
            this.houseSize = [3, 5, 7]
            console.error(" GRID SIZE height: ", this.size_h, "width: ", this.size_h)
            for (var i = 0; i < this.size_h; i++) {
                this.grid[i] = new Array(this.size_w);
                for (var j = 0; j < this.size_w; j++) 
                {
                    if (Math.random() < 0.65)
                        this.grid[i][j] = celltype.EMPTY
                    else
                        this.grid[i][j] = celltype.ROCK
                }
            }
        }

        drawBorder() {
            for (var y = 0; y < this.size_h; y++)
             {
                for (var x = 0; x < this.size_w; x++) 
                {
                    if (x == 0 || x == this.size_w -1 || y == 0 || y == this.size_h - 1) 
                        fill_pos(x + this.startX, y + this.startY, "red")
                }
            }
        }

        drawPos(pos, color) 
        {
            fill_pos(pos.x + this.startX, pos.y + this.startY, color)
        }

        selectDirection() {
            var rand = Math.floor(Math.random() * 4)
            return NESW[rand];
        }

        makeHouses(num) 
        {
            var houses = Array()
            for (var i = 0; i < num; i++) {
                var size = this.houseSize[random(0, this.houseSize.length)]
                houses.push({"size_w" : size, "size_h": size, "door_e": true, "door_w": true, "door_n": true, "door_s": true})
            }
            return houses
        }

        empty(y, x) {
            console.log("trying pos(", x, ", ", y, ")")
            //console.log(this.grid[y][x])
            if (y >= this.size_w || this.x >= this.size_w || y <= 0 || x <= 0)
                return false
            return (this.grid[y][x] == celltype.EMPTY)
        }
        
        addHouse(y, x, house) {
            for (var i = y; i < y + house.size_h; i++)
                for (var j = x; j < x + house.size_w; j++)
                    if (j == x && house.door_w && i == y + (house.size_h - 1) / 2 ) {
                        this.grid[i][j] = celltype.ROOM_DOOR
                    }
                    else if (j == x + (house.size_w - 1) && house.door_e && i == y + (house.size_h - 1) / 2 ) {
                        this.grid[i][j] = celltype.ROOM_DOOR
                    }
                    else if (j == x + (house.size_w - 1) / 2 && house.door_n && i == y ) {
                        this.grid[i][j] = celltype.ROOM_DOOR
                    }
                    else if (j == x + (house.size_w - 1) / 2 && house.door_s && i == y + (house.size_h - 1) ) {
                        this.grid[i][j] = celltype.ROOM_DOOR
                    }
                    else
                        this.grid[i][j] = celltype.ROOM_FLOOR

        }

        canPlaceHouse(x, y, house) {
            var w = house.size_w
            var h = house.size_h
            var spacing = 1
            //check perimeters before checking every tile
            if (this.empty(y, x ) && this.empty(y + h + spacing , x + w + spacing) && this.empty(y + h + spacing, x) && this.empty(y, x + w + spacing)) {
                for (i = y; i < h; i++)
                    for (j = x; j < w; j++)
                        if (!this.empty(i, j))
                            return false
                return true
            }
            return false
        }

        placeHouse(house) {
            var spacing = 1
            var w = house.size_w
            var h = house.size_h
            for (var y = 0; y < this.size_h; y += h) 
            {
                for (var x = 0; x < this.size_w; x += w ) 
                {
                    if (this.canPlaceHouse(x, y, house)) 
                    {
                        this.addHouse(y, x, house)
                        return
                    }
                }
            }

        }

        startGen() {
            var houses = this.makeHouses(40)
            // this.placeHouse(houses[0])
            for (var i = 0; i < houses.length; i++)
                this.placeHouse(houses[i])

            this.renderGrid()
        }

        renderGrid() {
            for (var y = 0; y < this.size_h; y ++) 
                {
                    for (var x = 0; x < this.size_w; x++ ) 
                    {
                        switch(this.grid[y][x]) {
                            case celltype.EMPTY:
                                break;
                            case celltype.ROOM_FLOOR:
                                fill_pos(this.startX + x, this.startY + y, "green")
                                break;
                            case celltype.ROOM_DOOR:
                                fill_pos(this.startX + x, this.startY + y, "yellow")
                                break;
                            case celltype.ROCK:
                                fill_pos(this.startX + x, this.startY + y, "gray")
                                break;
                        }
                    }
                }
            }
    }

    var zones = Array()
    zones.push(new Zone(1, 1, 40, 40))
    zones.push(new Zone(50, 1, 40, 40))
    zones.push(new Zone(1, 50, 40, 40))
    zones.push(new Zone(50, 50, 40, 40))



    // draw initial grid
    for (i = 0; i < grid_h; i++)
    {
        for (j = 0; j < grid_w; j++)
        {
            ctx.strokeStyle = "#000"
            ctx.lineWidth = 0.1
            ctx.strokeRect(0 + grid_s * j, 0 + grid_s * i, grid_s, grid_s);
            if (enumerate) {
                ctx.fillStyle = "#000"
                ctx.font = "6px Arial";
                ctx.fillText(i * grid_w + j + "", 0 + grid_s * j + 5, 0 + grid_s * i + 13);
            }
        }
    }
    // zones[0].drawBorder()
    // zones[0].startGen()
    // grid
    zones.forEach(zone => {
        zone.drawBorder()
        zone.startGen()
    });

</script>